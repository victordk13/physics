<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="https://victordk13.github.io/physics_test/math.min.js"></script>
    <style>
    html, body {
      width:  100%;
      height: 100%;
      border: 0;
      margin: 0px;
      overflow: hidden;
    }
    </style>

    <script>
var canvas;
var stage;
var shape;

var g  = 9.8;      // m/s^2
var m  = [1., 1.]; // only proportion matters
var l  = [1., 1.]; // also in m, and make it life-sized for better effect
var th = [1.5, 1.5]; // in radians
var th_spd = [0., 0.];
var th_acc; // to solve for
var diss = 0.001;

var vlength = [0, 0];

var A, b, L;

function calcVlength() {
    var size = Math.min(canvas.width, canvas.height) / 3;
    vlength[0] = l[0] * size / (l[0] + l[1]);
    vlength[1] = l[1] * size / (l[0] + l[1]);
}

function LK() {
  return 1/2 * (m[0] + m[1]) * Math.pow(l[0], 2) * Math.pow(th_spd[0], 2) 
    + 1/2 * m[1] * Math.pow(l[1], 2) * Math.pow(th_spd[1], 2) 
    + m[1] * l[0] * l[1] * th_spd[0] * th_spd[1] * Math.cos(th[0] - th[1]);
}

function LP() {
  return (m[0] + m[1]) * g * l[0] * Math.cos(th[0]) 
    + m[1] * g * l[1] * Math.cos(th[1]);
}

function Lagrangian() {
  return LK() + LP();
}

function init() {
    L = Lagrangian();
    solve();

    // create a new stage and point it at our canvas:
    canvas = document.getElementById("testCanvas");
    stage = new createjs.Stage(canvas);
    
    calcVlength();
    for (var i = 0; i < 2; i++) {
        shape = new createjs.Shape();
        shape.graphics
            .setStrokeStyle(2)
            .beginFill("#FFF")
            .beginStroke("#222")
            .drawRoundRect(0, 0, 20, vlength[i] + 20, 5)
            .moveTo(10, 10)
            .drawCircle(10, 10, 2);

        shape.regX = shape.regY = 10;
        shape.x = canvas.width / 2;
        shape.y = canvas.height / 2;
        //shape.velX = Math.random() * 10 - 5;
        //shape.velY = Math.random() * 10 - 5;

        // turn snapToPixel on for all shapes - it's set to false by default on Shape.
        // it won't do anything until stage.snapToPixelEnabled is set to true.
        // shape.snapToPixel = true;

        stage.addChild(shape);
    }

    // add a text object to output the current FPS:
    fpsLabel = new createjs.Text("-- fps", "bold 18px Arial", "#000");
    stage.addChild(fpsLabel);
    fpsLabel.x = 10;
    fpsLabel.y = 20;

    // start the tick and point it at the window so we can do some work before updating the stage:
    createjs.Ticker.timingMode = createjs.Ticker.RAF;
    createjs.Ticker.addEventListener("tick", tick);
}

// https://www.wolframalpha.com/input/?i=double+pendulum see Equations of motion
function solve() {
    // calculate concrete values of equation    
    A = [ 
        [(m[0] + m[1]) * l[0], m[1] * l[1] * Math.cos(th[0] - th[1])],
        [l[1], l[0] * Math.cos(th[0] - th[1])]
    ];
    b = [
        - m[1] * l[1] * Math.pow(th_spd[1], 2) * Math.sin(th[0] - th[1]) - (m[0] + m[1]) * g * Math.sin(th[0]),
        l[0] * Math.pow(th_spd[0], 2) * Math.sin(th[0] - th[1]) - g * Math.sin(th[1])
    ];
    // solve for angular acceleration
    th_acc = math.lusolve(A, b);
}

function normalize() {
  // computation errors will accumulate so we need at least keep total L constant
  var lk = LK();
  var lp = LP();
  if (lp <= L) {
    var mul = Math.sqrt((L - lp) / lk);
    th_spd[0] *= mul;
    th_spd[1] *= mul;
  }
  // else lk should be negative; we are fucked, let's do nothing
}

function step(time) {
    var old_spd = th_spd;
    // don't update speeds if solution is invalid
    if (Array.isArray(th_acc) && isFinite(th_acc[0]) && isFinite(th_acc[0]))
    {
        if (Math.abs(th_acc[0]) > 1.e4)
          console.log(th_acc);
        else {
          th_spd[0] += th_acc[0] * time;
          th_spd[1] += th_acc[1] * time;
        }
    }
    //th_spd[0] *= (1 - diss * time);
    th[0] += (old_spd[0] + th_spd[0]) * time / 2;
    th[1] += (old_spd[1] + th_spd[1]) * time / 2;
    
    normalize();
}

function draw() {
    calcVlength();
    var x = canvas.width / 2;
    var y = canvas.height / 2;
    for (var i = 0; i < 2; i++) {
        var shape = stage.getChildAt(i);
        shape.x = x;
        shape.y = y;
        shape.rotation = th[i] * 180 / Math.PI;
        
        x -= vlength[i] * Math.sin(th[i]);
        y += vlength[i] * Math.cos(th[i]);
    }
}

function tick(event) {
    
    solve();
    
    fps = createjs.Ticker.getMeasuredFPS();
    
    if (fps < 10)
      return;
        
    step(1. / createjs.Ticker.getMeasuredFPS());
    
    draw();
    
    fpsLabel.text = Math.round(createjs.Ticker.getMeasuredFPS()) + " fps";

    // draw the updates to stage:
    stage.update(event);
}

function toggleCache(value) {
    // iterate all the children except the fpsLabel, and set up the cache:
    //var l = stage.numChildren - 1;

    for (var i = 0; i < 2; i++) {
        var shape = stage.getChildAt(i);
        if (value) {
            shape.cache(0, 0, 20, vlength[i] + 20);
        } else {
            shape.uncache();
        }
    }
}
    </script>   
  </head>
  <body onload="init();">
    <div class="controls">
      <input type="checkbox" onClick="toggleCache(this.checked);" id="toggleCache"/>
      <label for="toggleCache">cache enabled</label>
    </div>
    <canvas id="testCanvas" width="720" height="720">Your browser doesn't support "canvas".</canvas>
  </body>
</html>
