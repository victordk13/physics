<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="https://victordk13.github.io/physics_test/math.min.js"></script>
    <style>
    html, body {
      width:  100%;
      height: 100%;
      border: 0;
      margin: 0px;
      overflow: hidden;
    }
    </style>

    <script>
var canvas;
var stage;
var shape;

var g       = 9.8;      // m/s^2
var m       = [1., 1.]; // only proportion matters
var l       = [1., 0.7]; // also in m, and make it life-sized for better effect
var th      = [1.2, 1.2]; // in radians
var th_spd  = [0., 0.];
var p       = [0,0];
var p_spd   = [0,0];
//var th_acc; // to solve for
var diss    = 0.00;

var vlength = [0, 0];

var A, b, E;
var div, C1, C2, cdiff, sdiff; // TODEL

function calcVlength() {
    var size = Math.min(canvas.width, canvas.height) / 3;
    vlength[0] = l[0] * size / (l[0] + l[1]);
    vlength[1] = l[1] * size / (l[0] + l[1]);
}

function LK() {
  return 1/2 * (m[0] + m[1]) * l[0] * l[0] * th_spd[0] * th_spd[0] 
    + 1/2 * m[1] * l[1] * l[1] * th_spd[1] * th_spd[1] 
    + m[1] * l[0] * l[1] * th_spd[0] * th_spd[1] * Math.cos(th[0] - th[1]);
}

function LP() {
  return - (m[0] + m[1]) * g * l[0] * Math.cos(th[0]) 
    - m[1] * g * l[1] * Math.cos(th[1]);
}

function Lagrangian() {
  return LK() - LP();
}

function Energy() {
  return LK() + LP();
}

function solveViaHamiltonian() {
  cdiff = Math.cos(th[0] - th[1]);
  sdiff = Math.sin(th[0] - th[1]);

  // 1 & 2 must be opposite, so one of them is useless, but we need p_spd to update p
  // and th_spd is how we move the pendulums
  p[0] = (m[0]+m[1]) * l[0] * l[0] * th_spd[0]
    +          m[1]  * l[0] * l[1] * th_spd[1] * cdiff;
  p[1] =       m[1]  * l[1] * l[1] * th_spd[1] 
    +          m[1]  * l[0] * l[1] * th_spd[0] * cdiff;
  
  div = l[0] * l[1] * (m[0] + m[1] * sdiff * sdiff);
  
  C1 = p[0] * p[1] * sdiff / div;
  C2 = (l[1] * l[1] * m[1] * p[0] * p[0] + l[0] * l[0] * (m[0] + m[1]) * p[1] * p[1]
    - 2 * l[0] * l[1] * m[1] * p[0] * p[1] * cdiff) * Math.sin(2 * (th[0] - th[1]))
    / 2 / m[1] / div / div;
    
  p_spd[0] = - (m[0]+m[1]) * g * l[0] * Math.sin(th[0]) - C1 + C2;
  p_spd[1] = -       m[1]  * g * l[1] * Math.sin(th[1]) + C1 - C2;

}

function stepViaHamiltonian(dur) {
  // update p? update th?
  p[0] += p_spd[0] * dur;
  p[1] += p_spd[1] * dur;
  
  var div = l[0] * l[1] * (m[0] + m[1] * sdiff * sdiff);
  // 2
  th_spd[0] = (l[1] * p[0] - l[0] * p[1] * cdiff) / l[0] / div;
  th_spd[1] = ((m[0]+m[1]) * l[0] * p[1] - m[1] * l[1] * p[0] * cdiff) / l[1] / m[1] / div;  

  //th_spd[0] *= (1 - diss * dur); // friction
  //th_spd[1] *= (1 - diss * dur);
  
  E -= LK() * diss * dur;
  
  th[0] += th_spd[0] * dur;
  th[1] += th_spd[1] * dur;
  
  normalize();
}

function init() {
    E = Energy();
    solveViaHamiltonian();

    // create a new stage and point it at our canvas:
    canvas = document.getElementById("testCanvas");
    stage = new createjs.Stage(canvas);
    
    calcVlength();
    for (var i = 0; i < 2; i++) {
        shape = new createjs.Shape();
        shape.graphics
            .setStrokeStyle(2)
            .beginFill("#FFF")
            .beginStroke("#222")
            .drawRoundRect(0, 0, 20, vlength[i] + 20, 5)
            .moveTo(10, 10)
            .drawCircle(10, 10, 2);

        shape.regX = shape.regY = 10;
        shape.x = canvas.width / 2;
        shape.y = canvas.height / 2;
        //shape.velX = Math.random() * 10 - 5;
        //shape.velY = Math.random() * 10 - 5;

        // turn snapToPixel on for all shapes - it's set to false by default on Shape.
        // it won't do anything until stage.snapToPixelEnabled is set to true.
        // shape.snapToPixel = true;

        stage.addChild(shape);
    }

    // add a text object to output the current FPS:
    fpsLabel = new createjs.Text("-- fps", "bold 18px Arial", "#000");
    stage.addChild(fpsLabel);
    fpsLabel.x = 10;
    fpsLabel.y = 20;

    // start the tick and point it at the window so we can do some work before updating the stage:
    createjs.Ticker.timingMode = createjs.Ticker.RAF;
    createjs.Ticker.addEventListener("tick", tick);
}

// http://scienceworld.wolfram.com/physics/DoublePendulum.html
function solve() {
    // calculate concrete values of equation
    A = [ 
        [(m[0] + m[1]) * l[0], m[1] * l[1] * Math.cos(th[0] - th[1])],
        [l[1], l[0] * Math.cos(th[0] - th[1])]
    ];
    b = [
        - m[1] * l[1] * th_spd[1] * th_spd[1] * Math.sin(th[0] - th[1]) - (m[0] + m[1]) * g * Math.sin(th[0]),
        l[0] * th_spd[0] * th_spd[0] * Math.sin(th[0] - th[1]) - g * Math.sin(th[1])
    ];
    // solve for angular acceleration
    th_acc = math.lusolve(A, b);
}

function normalize() {
  // computation errors will accumulate so we need at least keep total L constant
  var lk = LK();
  var lp = LP();
  if (lp <= E) {
    var mul = Math.sqrt((E - lp) / lk);
    th_spd[0] *= mul;
    th_spd[1] *= mul;
  }
  // else lk should be negative; we are fucked, let's do nothing
}

function step(time) {
    var old_spd = th_spd;
    // don't update speeds if solution is invalid
    if (Array.isArray(th_acc) && isFinite(th_acc[0]) && isFinite(th_acc[0]))
    {
        if (Math.abs(th_acc[0]) > 1.e4)
          console.log(th_acc);
        else {
          th_spd[0] += th_acc[0] * time;
          th_spd[1] += th_acc[1] * time;
        }
    }
    //th_spd[0] *= (1 - diss * time); // friction
    th[0] += (old_spd[0] + th_spd[0]) * time / 2;
    th[1] += (old_spd[1] + th_spd[1]) * time / 2;
    
    //normalize(); // constant energy
}

function draw() {
    calcVlength();
    var x = canvas.width / 2;
    var y = canvas.height / 2;
    for (var i = 0; i < 2; i++) {
        var shape = stage.getChildAt(i);
        shape.x = x;
        shape.y = y;
        shape.rotation = th[i] * 180 / Math.PI;
        
        x -= vlength[i] * Math.sin(th[i]);
        y += vlength[i] * Math.cos(th[i]);
    }
}

function tick(event) {    
    dur = 1. / createjs.Ticker.getMeasuredFPS();
    step = 0.005;
    
    for (var t = 0; t < dur; t += step)
    {
      solveViaHamiltonian();
    
      stepViaHamiltonian(dur > t + step ? step : dur - t);
    }
    draw();
    
    fpsLabel.text = Math.round(1. / dur) + " fps, E = " + Math.round(Energy()*100)/100;

    // draw the updates to stage:
    stage.update(event);
}

function toggleCache(value) {
    // iterate all the children except the fpsLabel, and set up the cache:
    //var l = stage.numChildren - 1;

    for (var i = 0; i < 2; i++) {
        var shape = stage.getChildAt(i);
        if (value) {
            shape.cache(-1, -1, 22, vlength[i] + 22);
        } else {
            shape.uncache();
        }
    }
}
    </script>   
  </head>
  <body onload="init();">
    <div class="controls">
      <input type="checkbox" onClick="toggleCache(this.checked);" id="toggleCache"/>
      <label for="toggleCache">cache enabled</label>
    </div>
    <canvas id="testCanvas" width="720" height="720">Your browser doesn't support "canvas".</canvas>
  </body>
</html>
