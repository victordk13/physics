<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <style title="gas-main-style">
    html, body {
      width:  100%;
      height: 100%;
      border: 0;
      margin: 0px;
      overflow: hidden;
      position: relative;
    }
    
    .controls {
      display: inline-block;
      width:  100%;
      height: 40px;
      padding: 10;
    }
    
    .controls .slider {
      width: 45%;
      height: 40px;
      margin: 10;
    }
    
    canvas {position:absolute;}
    #boxCanvas { left:0 }
    </style>

  </head>
  <body onload="init();">
    <div class="controls">
      <input type="checkbox" onClick="toggleCache(this.checked);" id="toggleCache"/>
      <label for="toggleCache">cache enabled</label>
    </div>
    <canvas id="boxCanvas" width="1280" height="720">Your browser doesn't support "canvas".</canvas>
    
<script>
var canvas;
var stage;
var paused = false;

var epsilon = 1.e-6;
var g = 2;
var N = 2;
var box = {w: 100, h: 100, l: 0, t: 0, r: 100, b: 100, v: [0, 0, 0, 0]};
var stats = {};
var molecules = [];

var vchart;

class Vec {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  // square of distance (try not to call Math.sqrt)
  static distanceSq(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return dx*dx + dy*dy;
  }
  
  static dot(a, b) {
    return a.x*b.x + a.y*b.y;
  }
  
  static add(a, b) {
    return new Vec(a.x + b.x, a.y + b.y);
  }
  
  static sub(a, b) {
    return new Vec(a.x - b.x, a.y - b.y);
  }
  
  static neg(a) {
    return new Vec(-a.x, -a.y);
  }
  
  static mul(a, n) {
    return new Vec(a.x * n, a.y * n);
  }
}

function init() {

    // create a new stage and point it at our canvas:
    canvas = document.getElementById("boxCanvas");
    stage = new createjs.Stage(canvas);
    
    
    for (var i = 0; i < N; i++) {
        var mol = {};
        mol.shape = new createjs.Shape();

        // all physical values in SI (m, s, etc.), even though they are bogus, all draw_* values in pixels
        mol.m = 1;
        mol.rad = 0.3;
        
        if (i==0) {
          mol.m = 38;
          mol.rad = 18;
          const bbv = Math.PI * mol.rad * mol.rad;
          console.log("Big ball density = " + (mol.m / bbv));
          console.log("Gas density = " + (1 * (N-1) / (box.w * box.h - bbv)));
        }

        //mol.tx =  Math.random() * (box.w - 2) + 1;
        //mol.ty =  Math.random() * (box.h - 2) + 1;
        do {
          mol.pos = new Vec(
            Math.random() * (box.w - 2 * mol.rad) + mol.rad, 
            Math.random() * (box.h - 2 * mol.rad) + mol.rad);
        } while (i>0 && Vec.distanceSq(mol.pos, molecules[0].pos) < 
          (mol.rad + molecules[0].rad)*(mol.rad + molecules[0].rad));
          
        //mol.pos = new Vec(30 + i * 40, 50);
        
        // same speed, random direction
        v = 10; // (initial) 1-frame displacement will be v/fps
        th = 2 * Math.PI * Math.random();
        //mol.vx = v * Math.cos(th);
        //mol.vy = v * Math.sin(th);
        mol.v = new Vec(v * Math.cos(th), v * Math.sin(th));
        
        //mol.v = new Vec(10 - i * 20, 0);
        
        // turn snapToPixel on for all shapes - it's set to false by default on Shape.
        // it won't do anything until stage.snapToPixelEnabled is set to true.
        // shape.snapToPixel = true;

        stage.addChild(mol.shape);
        molecules.push(mol);
    }
    box.shape = new createjs.Shape();
    stage.addChild(box.shape);
    stats = calcStats(molecules);

    // add a text object to output the current FPS:
    fpsLabel = new createjs.Text("-- fps", "bold 18px Arial", "#000");
    stage.addChild(fpsLabel);
    fpsLabel.x = 10;
    fpsLabel.y = 20;

    // start the tick and point it at the window so we can do some work before updating the stage:
    createjs.Ticker.timingMode = createjs.Ticker.RAF;
    createjs.Ticker.addEventListener("tick", tick);
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas, false);
    
    window.addEventListener("focus", function(event) { paused = false; });
    window.addEventListener("blur", function(event) { paused = true; });
}

function translateX(x) {
  var bs = Math.min(canvas.width, canvas.height);
  return (canvas.width - bs) / 2 + x * bs / box.w;
}

function translateY(y) {
  var bs = Math.min(canvas.width, canvas.height);
  return (canvas.height - bs) / 2 + y * bs / box.h;
}

function resize() {
  var bs = Math.min(canvas.width, canvas.height);
  //box.shape.width = box.shape.height = bs;
  box.shape.x = translateX(0);
  box.shape.y = translateY(0);
  
  box.shape.graphics
    .clear()
    .setStrokeStyle(1)
    .beginStroke("#000")
    .drawRect(0, 0, translateX(box.r) - translateX(box.l), translateY(box.b) - translateY(box.t));
  
  molecules.forEach(function(mol) {
    mol.draw_r = mol.rad * bs / box.w;
    mol.shape.graphics
      .clear()
      .setStrokeStyle(1)
      .beginStroke("rgb(" 
        + Math.round(Math.random() * 255) + ","
        + Math.round(Math.random() * 255) + ","
        + Math.round(Math.random() * 255) + ")")
      .drawCircle(0, 0, mol.draw_r);
  });
}

function draw() {
  //console.log(translateX(box.l), translateX(box.r) - translateX(box.l));

  molecules.forEach(function(mol) {
    mol.shape.x = translateX(mol.pos.x);
    mol.shape.y = translateY(mol.pos.y);
  });
}

// bounce and reflect molecules against walls
// TODO: calculate the force/moment imparted by each molecule into the wall (calc. pressure, move box, etc.)
//       must be m*(vx0 - vx1) (e.g. for a vertical wall)
// TODO: add collision processing for molecules outside the box (for future experiments) 
function reflect(obj, box) {
  if (obj.pos.x <= box.l + obj.rad)
  {
    obj.pos.x = 2 * (box.l + obj.rad) - obj.pos.x;
    if (obj.v.x - box.v[0] < 0)
      obj.v.x = - obj.v.x + 2 * box.v[0];
  }
  if (obj.pos.y <= box.t + obj.rad)
  {
    obj.pos.y = 2 * (box.t + obj.rad) - obj.pos.y;
    if (obj.v.y - box.v[1] < 0)
      obj.v.y = - obj.v.y + 2 * box.v[1];
  }
  
  if (obj.pos.x >= box.r - obj.rad)
  {
    obj.pos.x = 2 * (box.r - obj.rad) - obj.pos.x;
    if (obj.v.x - box.v[2] > 0)
      obj.v.x = - obj.v.x + 2 * box.v[2];
  }
  if (obj.pos.y >= box.b - obj.rad)
  {
    obj.pos.y = 2 * (box.b - obj.rad) - obj.pos.y;
    if (obj.v.y - box.v[3] > 0)
      obj.v.y = - obj.v.y + 2 * box.v[3];
  }
}

// ax^2+bx+c=0
function solveQuad(a, b, c) {
    var D = b * b - 4 * a * c;
    if (D < 0)
      return [-Infinity, -Infinity];
    var d = Math.sqrt(d);
    var result1 = (-b - d) / (2 * a);
    var result2 = (-b + d) / (2 * a);
    return [result1, result2];
}

function reflectionTime(obj, box) {
  var nearest = Infinity;
  var results = [];
  if(g) {
    var res = solveQuad(g/2, obj.v.y, obj.pos.y - box.t);
    results.push(res[0], res[1]);
    res = solveQuad(g/2, obj.v.y, obj.pos.y - box.b);
    results.push(res[0], res[1]);
  } else {
    results.push((box.t - obj.pos.y) / obj.v.y);
    results.push((box.b - obj.pos.y) / obj.v.y);
  }
  results.push((box.l - obj.pos.x) / obj.v.x);
  results.push((box.r - obj.pos.x) / obj.v.x);
  results.forEach(function(t) {
    if (t >= 0 && t < nearest)
      nearest = t;
  });
  return nearest;
}

function collisionTime(mol1, mol2) {
  var v = Vec.sub(mol1.v, mol2.v);
  var x = Vec.sub(mol2.pos, mol1.pos);
  var vsq = Vec.dot(v,v);
  
  var t = Vec.dot(x,v)/vsq;
  if (t < 0)
    return -Infinity; // don't care about collisions in the past
  var min = (x.x - t*v.x)*(x.x - t*v.x) + (x.y - t*v.y)*(x.y - t*v.y);
  var Rsq = (mol1.rad + mol2.rad) * (mol1.rad + mol2.rad);
  if (min > Rsq)
    return -Infinity; // it's a miss
  // collision is not at a minimum distance, but some time before (at r1+r2 distance between balls' centers)
  // TODO: use approximate value instead of Math.sqrt()?
  delta = Math.sqrt((Rsq - min) / vsq);
  return t - delta;
}

// time of collision to avoid calculating twice
function collide(mol1, mol2, time) {
  //console.log(
  //  mol1.pos.x, mol1.pos.y, mol1.v.x, mol1.v.y, 
  //  mol2.pos.x, mol2.pos.y, mol2.v.x, mol2.v.y, time);
    
  var pos1 = Vec.add(mol1.pos, Vec.mul(mol1.v, time));
  var pos2 = Vec.add(mol2.pos, Vec.mul(mol2.v, time));
  
  mol1.pos = pos1;
  mol2.pos = pos2;
  // (m1*v1 + m2*v2) / (m1 + m2)
  var vc = Vec.mul(Vec.add(Vec.mul(mol1.v, mol1.m), Vec.mul(mol2.v, mol2.m)), 1/(mol1.m + mol2.m));
  var x = Vec.sub(pos2, pos1);
  var v1c = Vec.sub(mol1.v, vc);
  mol1.v = Vec.sub(mol1.v, Vec.mul(x, 2 * Vec.dot(v1c, x)/Vec.dot(x, x)));
  var v2c = Vec.sub(mol2.v, vc);
  mol2.v = Vec.sub(mol2.v, Vec.mul(x, 2 * Vec.dot(v2c, x)/Vec.dot(x, x)));
  
  //console.log(pos1.x, pos1.y, pos2.x, pos2.y, vc.x, vc.y, x.x, x.y, 
  //  mol1.v.x, mol1.v.y, mol2.v.x, mol2.v.y);
}

function stupidCollisions(mol, index, dur) {
  var collided = false;
  molecules.forEach(function(mol2, index2) {
    if (index != index2) {
      var t = collisionTime(mol, mol2);
      if (isFinite(t) && dur >= t) {
        collide(mol, mol2, t);
        collided = true;
      }
    }
  });
  return collided;
}

function move(dur) {
  // TODO: we calculate future collisions on each tick; should rather keep a list and update it
  var collisions = [];
  // create a list of nearest collisions
  // let's process reflections at initial position (to simplify things)
  molecules.forEach(function(mol, index) {
    var t = reflectionTime(mol, box);
    if (isFinite(t) && dur >= t)
      collisions.push([index, -1, t]);
    molecules.forEach(function(mol2, index2) {
      var t = collisionTime(mol, mol2);
      if (isFinite(t) && dur >= t)
        collisions.push([index, index2, t]);
    });
    
    /* TODO: MOVE stupidCollisions(mol, index, dur);
    mol.pos.x += mol.v.x * dur;
    mol.pos.y += mol.v.y * dur + g * dur * dur / 2;
    mol.v.y += g * dur;
    reflect(mol, box);*/
  });
  collisions.sort(function(a, b) {
    return a[2] - b[2]; // sort by time
  });
  // TODO: now go through the list, advance the state and then process collisions
  // As we process each collision exactly at its time, there should be no E fluctuations in g field (due to incorrect particle positions)
  collisions.forEach(function(col) {
    // 0. advance the state by col[2] (=t)
    // 1. collide or reflect particle(s)
    // 2. calculate new nearest collision&reflection for the colliding particle(s)
    // 3. insert in collisions array - this means forEach is not suitable
  });
  
  // move the box to a next position (might be some overlap, but it won't be a bother if we keep box speeds low)
  box.l += box.v[0] * dur;
  box.t += box.v[1] * dur;
  box.r += box.v[2] * dur;
  box.b += box.v[3] * dur;
}

function calcStats(arr) {
  var stats = {vMax: 0, vMin: Infinity, vAvg: 0, Esum: 0, RMS: 0};
  var len = arr.length;
  while (len--) {
    var v2 = Vec.dot(arr[len].v, arr[len].v);
    var v = Math.sqrt(v2);
    if (v > stats.vMax) {
      stats.vMax = v;
    }
    if (v < stats.vMin) {
      stats.vMin = v;
    }
    stats.vAvg += v;
    stats.Esum += arr[len].m*v2/2 - arr[len].m*arr[len].pos.y*g;
    stats.RMS += v2;
  }
  stats.vAvg /= arr.length;
  stats.RMS = Math.sqrt(stats.RMS / arr.length);
  return stats;
}

function tick(event) {
    if (paused || createjs.Ticker.getMeasuredFPS() < 1.)
      return;
    dur = 1. / createjs.Ticker.getMeasuredFPS();
    step = 0.005;
    
    /*for (var t = 0; t < dur; t += step)
    {
      // TODO: advance the model by a step
    }*/
    move(dur);
    draw();
    stats = calcStats(molecules);
    
    fpsLabel.text = Math.round(1. / dur) + " fps, RMS = " + stats.RMS.toFixed(2) + ", E = " + stats.Esum.toFixed(2);

    // draw the updates to stage:
    stage.update(event);
}

function toggleCache(value) {
    // iterate all the children except the fpsLabel, and set up the cache:
    //var l = stage.numChildren - 1;
    
    molecules.forEach(function(mol) {
        if (value) {
            mol.shape.cache(-mol.draw_r - 1, -mol.draw_r - 1, 2*mol.draw_r + 2, 2*mol.draw_r + 2);
        } else {
            mol.shape.uncache();
        }      
    });
}

// window size change handler
function resizeCanvas() {
  var rect = canvas.getBoundingClientRect();

  canvas.width = window.innerWidth - 20;
  canvas.height = window.innerHeight - rect.top - 20;
  resize();
}

</script>

  </body>
</html>
